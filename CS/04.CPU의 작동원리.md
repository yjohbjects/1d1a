# Chapter 04 CPU의 작동원리



#### 목차

1. ALU와 제어장치
2. 레지스터
3. 명령어 사이클과 인터럽트



## 1. ALU와 제어장치

### ALU

계산에 필요한 피연산자와 제어신호를 입력받아 계산을 수행 후 결과값과 플래그(결과값에 대한 부가정보)를 내보낸다.

![image-20221216185416642](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216185416642.png)



받아들이는 정보

- 피연산자 from 레지스터
- 제어 신호 from 제어장치

피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산 수행



내보내는 정보

- 결괏값 to 레지스터
  - CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 더 빠름
  - 레지스터에 저장된 정보를 가지고 메모리에 저장한다던지, 이 값을 가지고 추가적인 연산을 함
- 플래그 to 플래그 레지스터



![image-20221216190022079](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216190022079.png)





![image-20221216204004621](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216204004621.png)

위 같은 경우는 부호 플래그 = 1 이므로 결과값이 음수임을 알 수 있다.

![image-20221216203913351](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216203913351.png)

위 같은 경우는 제로 플래그 = 1 이므로 결과값이 0인 것을 알 수 있다.



### 제어장치

제어 신호를 내보내고, 명령어를 해석하는 부품

제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호



![image-20221216204201767](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216204201767.png)



받아들이는 정보

- 클럭 신호
  - 클럭(clock)이란 컴퓨터의 모든 부품을 움직이게 하는 시간 단위
  - 클럭의 주기에 맞춰서 레지스터에서 다른 레지스터로 데이터가 이동하거나, ALU가 연산을 하는 등 행동을함
  - 한 클럭에 한동작씩 작동하는 것이 아님. 그림처럼 하나의 명령어가 여러 클럭에 걸쳐서 실행되기도 함
  - ![image-20221216204552736](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216204552736.png)

- 해석해야 할 명령어
  - CPU가 해석해야 할 명령어는 '명렁어 레지스터'에 저장됨
  - 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어신호를 발생시켜 컴퓨터 부품들에 수행해야할 내용을 전달함
- 플래그 값
  - 플래그 레지스터로 부터 플래그 정보 받음
  - 플래그 값을 참고하여 제어신호를 발생
- 제어신호
  - 제어 버스(시스템 버스)를 통해서 외부로부터 전달된 제어 신호를 받음



내보내는 정보

- 제어 신호 TO CPU 내부
  - ALU에 수행할 연산을 지시하기 위한 제어 신호
  - 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위한 제어 신호
- 제어 신호 TO CPU 외부
  - CPU 외부로 제어 신호를 내보낸 다는것은 제어 버스를 통해 신호를 내보낸다는 뜻
  - 대표적으로 메모리에 전달하는 제어 신호, 입출력장치에 전달하는 제어 신호가 있음



## 2. 레지스터



레지스터 종류

- 프로그램 카운터
  - 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어의 주소)
- 명렁어 레지스터
  - 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)
- 메모리 주소 레지스터
  - 메모리의 주소
- 메모리 버퍼 레지스터
  - 메모리와 주고받을 값 (데이터와 명령어)



![image-20221216210150599](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210150599.png)



![image-20221216210208539](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210208539.png)

![image-20221216210234804](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210234804.png)

![image-20221216210248457](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210248457.png)

![image-20221216210336026](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210336026.png)

![image-20221216210410003](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210410003.png)

![image-20221216210433802](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216210433802.png)

위처럼 프로그램 카운터가 증가하기 때문에 프로그램이 순차적으로 실행된다

순차적인 흐름이 끊기는 경우

- 특정 메모리 주소로 실행 흐름을 이동하라는 명령어(JUMP, CONDITIONALL JUMP, CALL 등)
- 인터럽트



- 플래그 레지스터
  - 연산 결과 또는 CPU 상태에 대한 부가적인 정보
- 범용 레지스터
  - 다양하고 일반적인 상황에서 자유롭게 사용
- 스택 포인터
  - 스택의 꼭대기를 가리키는 레지스터
- 베이스 레지스터
  - 기준 주소 저장



스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식



![image-20221216215445059](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215445059.png)



스택은 메모리에 스택처럼 사용할 수 있는 스택 영역에 있다

![image-20221216215505854](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215505854.png)



변위 주소 지정 방식 : 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소 얻음

![image-20221216215544483](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215544483.png)

![image-20221216215559018](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215559018.png)



상대 주소 지정 방식 : 오퍼랜드 필드의 값과 프로그램 카운터의 값을 더하여 유효 주소 얻기



![image-20221216215724907](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215724907.png)



베이스 레지스터 주소 지정 방식 : 오퍼랜드 필드의 값과 베이스 레지스터의 값을 더하여 유효 주소 얻기

![image-20221216215824987](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216215824987.png)



## 3. 명령어 사이클과 인터럽트

![image-20221216223057238](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216223057238.png)



#### 명령어 사이클

- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 `명령어 사이클`이라고 함



1. 인출 사이클
   - 메모리에 있는 명령어를 CPU로 가지고 오는 단계
   - ![image-20221216223503502](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216223503502.png)

2. 실행 사이클
   - CPU로 가져온 명령어를 실행하는 단계
   - ![image-20221216223602929](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216223602929.png)



일반적으로 인출 사이클과 실행 사이클이 반복되며 명령어가 실행됨

![image-20221216223719553](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216223719553.png)



그러나 간접 주소 지정 방식과 같이 명령어를 CPU로 가져왔다고 해도 곧바로 실행할 수 없는 경우가 있다.

```
간접 주소 지정 방식 : 오퍼랜드 필드에 유효 주소의 주소를 명시했기 때문에, 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없고 메모리 접근을 한 번 더 해야한다.
```

간접 주소 지정 방식처럼 추가적인 메모리 접근 단계를 `간접 사이클` 이라고 한다

![image-20221216224231969](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216224231969.png)



#### 인터럽트

- CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 `인터럽트`라고 한다.
- 주로 'CPU가 꼭 주목해야 할 때', 'CPU가 바로 처리해야 할 다른 작업이 생겼을 때' 발생함

![image-20221216224607355](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216224607355.png)

동기 인터럽트(예외) : CPU가 예기치 못한 상황을 접했을 때 발 생

- CPU가 접근하고자 하는 데이터에 접근했는데 원하는 데이터가 없는 경우
- 실행할 수 없는 명령어가 있는 경우
- 폴트 / 트랩 / 중단 / 소프트웨어 인터럽트



비동기 인터럽트 (하드웨어 인터럽트) : 주로 입출력장치에 의해 발생하는 인터럽트

- 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용

- 알림(세탁기 완료 알림, 전자레인지 조리 알림 등)과 같은 역할

![image-20221216225017642](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216225017642.png)

- 입출력 장치는 CPU보다 속도가 현저히 느리기 떄문에 CPU는 입출력 작업의 결과를 바로 받아볼 수 없다.
- 이 때 CPU가 하드웨어 인터럽트를 사용하지 않는다면 CPU는 프린터가 언제 프린트를 끝냈는지 모르기 때문에 주기적으로 프린트의 완료 여부를 확인해야함 
- 이로인해 CPU는 다른 생산적인 일을 할 수 없고 사이클 낭비로 이어짐
- 그러나 비동기 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료여부를 확인할 필요가 없고 프런터로부터 프린트 완료 인터럽트를 받을 때 까지 다른 일을 처리할 수 있다.



![image-20221216225100040](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216225100040.png)



하드웨어 인터럽트의 처리 순서

1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구하여 실행을 재개



- 인터럽트 요청 신호
  - 인터럽트 전에 CPU에 인터럽트를 요청해도 되는지 아닌지 확인

![image-20221216230223808](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216230223808.png)

- 인터럽트 플래그
  - 현재 CPU가 인터럽트를 받을 수 있는 상태를 표시하는 플래그
  - 모든 인터럽트를 인터럽트 플래그로 막을 수 있는 건 아님

![image-20221216230350096](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216230350096.png)

- 인터럽트 서비스 루틴
  - 인터럽트가 발생했을 때 해당 인터럽트를 처리하기 위한 프로그램
  - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
  - '마우스가 어떤 인터럽트 요청을 보냈을 때 어떻게 작동한다'
  - 인터럽트 서비스 루틴도 프로그램이기에 메모리에 저장



![image-20221216230749842](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216230749842.png)



- 인터럽트 벡터 
  - 각각의 인터럽트 서비스 루틴을 식별하기 위한 정보
  - 인터럽트의 주체에 따라서 인터럽트 서비스 루틴이 시작되는 위치를 확인

![image-20221216230912259](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216230912259.png)





- 인터럽트를 처리한다는 것은 현재 실행중인 명령어를 멈추고 인터럽트 서비스 루틴을 실행시킨단 말

- 인터럽트 서비스 루틴도 다른 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있음

- 때문에 인터럽트가 발생하기 전에 레지스터에 저장되어 있던 값들을 백업해둬야함

![image-20221216231133935](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216231133935.png)

![image-20221216231338968](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\04.CPU의 작동원리\image-20221216231338968.png)

- CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업함
- 그 후에 인터럽트 서비스 루틴이 실행됨
- 인터럽트를 처리한 후에 스택에 저장해둔 값을 CPU로 다시 불러와 이전까지 수행하던 작업을 재개
